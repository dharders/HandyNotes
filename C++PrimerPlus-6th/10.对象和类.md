title: 类与对象
date: 2021-04-09 09:40

---

### 抽象和类

- 指定基本类型完成了三项工作
  - 决定数据对象需要的内存数量
  - 决定如何解释内存中的位（如long和float）
  - 决定可使用数据对象执行的操作或方法
  
- C++结构体p345
  - **与类具有相同的特性**
  - 与类的**唯一区别**是：默认访问类型是public，类是private
  
- 内联方法
  - 定义位于类声明中将自动内联
  - 或在定义时用inline限定符（在类中**声明时不需要**）
  - 一般放在头文件中定义
  
- 默认构造函数
  - 当没有提供任何构造函数时，编译器提供默认构造函数
  - 若程序员提供了构造函数但没有提供默认构造函数则以下这种声明将出错
    ```c++
    Stock stock1;//Stock为类名
    ```
  
- 创建对象

  ```c++
  Stock stock("A", 1);
  ```

  ```c++
  Stock stock = Stock("A", 1);//这种可能和上面的行为一样，也可能创建一个临时对象，再将其复制到stock中，之后解构临时对象
  //临时对象的结构时间由编译器决定，不一定立刻解构
  ```

- const 成员函数p362

  - 声明

    ```c++
    void show() const;//保证this指针所指对象为const,即无法修改调用此函数的对象的属性
    ```

  - 定义

    ```c++
    void Stock::show() const {}
    ```

  - 这样才能确保允许 const 对象调用此方法

---

### 对象数组p368

- 关于返回值为引用的函数

  - 可以用指针型变量来接受返回值，但需要指向返回值的地址

    ```c++
    Stock &Stock::get() {}
    Stock *ptr = &stock.get();
    ```

---

### 类作用域p370

- 作用域内枚举

  - 传统枚举在枚举量相同的情况下会发生冲突

    ```c++
    enum A {one}
    enum B {one}//冲突
    ```

    

  - 新式枚举可以避免这种冲突

    ```c++
    enum class A {two}
    enum class B {two}//不冲突
    ```

  - 常规枚举可以自动转为整型

    ```c++
    A x = one;
    int y = x;//可行
    ```

  - 作用域内枚举不能隐式转为整形

    ```c++
    A x = A::two;
    int y = x;//不可行
    ```

---

### 总结p376

- 使用
  - 通常将类声明分成两部分组成，且放在不同文件中
    - 类声明应放在头文件中
    - 定义成员函数的源代码放在方法文件中

