#c-cpp #cg
## 2023.12.14

## c-cpp

### `char` `short` `int` `long` `long long`的长度

-   `char`：1 字节（按照标准，`char` 的大小是 1 字节）
-   `short`：至少 2 字节
-   `int`：至少与 `short` 一样长
-   `long`：至少 4 字节，并且至少与 `int` 一样长
-   `long long`：至少 8 字节，并且至少与 `long` 一样长

### 大端和小端的存储

**最高有效字节**（即“大端”）存储在内存的低地址端(网络字节序)   
**最低有效字节**（即“小端”）存储在内存的低地址端(x86)

### `malloc` 的底层实现

`malloc` 底层利用系统调用来从操作系统申请内存空间。在 Unix-like 系统中，这些系统调用可能是 `sbrk` 或 `mmap`（在现代系统中更常见）。

-   **`sbrk`**: 这个系统调用增加程序数据段的大小。`sbrk` 可以增加或减少数据段的尺寸，`malloc` 使用它来获取更多的内存。
-   **`mmap`**: 这个系统调用将文件或设备的一个区域映射到内存中，可以用于匿名映射（不与任何文件关联），从而为进程提供一块新的内存区域。

`malloc` 需要跟踪所有已分配和未分配的内存，它使用各种内存管理算法来有效地跟踪、分配和释放内存，例如：

-   **Free Lists**: 管理一系列未分配内存块的链表。(glibc (ptmalloc))
-   **Buddy System**: 将内存分割成大小为 2 的幂的块，并通过合并和分割相邻的内存块来管理内存。
-   **Slab Allocation**: 特别适用于频繁分配和释放的相同大小的对象。
-   **Segmented Lists**: 根据大小范围将内存分段，每个段有自己的空闲列表。

`malloc` 函数不保证可重入，因为它可能会修改全局或静态的内部数据结构，例如用于跟踪空闲内存和已分配内存的数据结构。

### cpp内存布局

C++对象在内存中的布局可以细分为以下几个区域：

- **代码段（Code Segment/Text Segment）**：存放程序的机器代码。
- **数据段（Data Segment）**：存放初始化的全局变量和静态变量。
- **BSS段（Block Started by Symbol）**：存放未初始化的全局变量和静态变量。
- **堆（Heap）**：用于动态内存分配，通过`new`、`malloc`等操作进行分配和收回。
- **rodata**: 字符串字面量和常量。
- **栈（Stack）**：存放函数的参数值、局部变量等。

### enable_shared_from_this

`std::enable_shared_from_this` 是 C++ 标准库中的一个模板类，它允许从一个已经由 `std::shared_ptr` 管理的对象内部获取该对象的新的 `std::shared_ptr` 实例。这样做的主要目的是确保对象生命周期的正确管理，尤其是在涉及到对象自身通过方法需要共享自身所有权时。

### `shared_ptr` 与 `make_shared`

使用 `std::make_shared` 创建 `shared_ptr` 时，只会进行一次动态内存分配。也就是计数块与对象分配在一起。

`std::make_shared` 无法指定自定义删除器。

### `static`函数与`inline`函数的链接

声明为内联链接，链接时只保留一个副本

使用nm

```obj
0000000000000000 T _Z1av // non static
```
```obj
0000000000000000 t _ZL1av // static
```
```obj
0000000000000000 W _Z1av // inline
```

使用readelf -a

```obj
Symbol table '.symtab' contains 5 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     3: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 _Z1av // non static
```

```obj
Symbol table '.symtab' contains 5 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     3: 0000000000000000    15 FUNC    LOCAL  DEFAULT    1 _ZL1av // static
```

```obj
Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     4: 0000000000000000    15 FUNC    WEAK   DEFAULT    6 _Z1av // inline
```

## 图形学

### Gamma空间

Gamma校正（Gamma Correction）是一种图像处理技术，用于调整由于显示设备非线性特性造成的亮度失真。人类视觉感知亮度的方式是非线性的，意味着我们对暗区域的变化比亮区域更为敏感。

在着色器（shader）里面进行的光照计算应该在线性空间中进行，而不是在Gamma空间。这是因为现实世界的光线是线性传播的，即光照的物理规律（如反射、折射和散射等）都遵循线性运算。

### 为什么Fresnel项可以作为镜面反射系数

**角度依赖性**：真实世界中，当光线以较低的角度（接近切线）入射到表面上时，反射比例会增加；而当光线垂直（或接近垂直）入射时，反射比例则相对较低。这意味着观察者从不同角度看向物体时，会感受到不同程度的反射亮度。Fresnel项正是用来计算这个随角度变化的反射比例的。
    
**能量守恒**：在任何给定的角度，表面的总反射量必须遵循能量守恒原则，即入射光的能量等于反射光与折射/吸收光的能量之和。Fresnel项给出了反射部分，剩下的部分自然就是漫反射和透射部分。

### 为什么把法线从模型空间变换到世界空间不能直接乘model矩阵

因为法线向量代表了表面的方向，而不是位置。法线是方向向量，不应受到平移的影响，只需受到旋转和缩放的影响。但是，当涉及到非均匀缩放时，直接使用模型矩阵会破坏法线的正确方向，因此需要特殊处理。

### Early-Z 和 Z Prepass

Early-Z 是一种硬件级别的优化技术，它允许GPU在进行像素着色之前先执行深度测试。

alpha-test, depth modify都会导致early-z失效，因为先做了深度测试会导致透明物体后面的东西无法通过深度测试而不进行渲染。

Z Prepass 是一个单独的渲染步骤，通常在主渲染循环开始之前完成。在这个预处理阶段，场景中的所有几何体仅使用一个简单的着色器（只输出深度信息，不进行任何颜色计算）进行绘制，从而在深度缓冲区中建立了正确的深度信息。在完成Z Prepass之后，当进行实际的渲染循环时，GPU就可以利用已填充的深度缓冲区数据来做优化——通过深度测试来决定是否需要执行更为复杂的颜色着色器。

!!! Note 此处的深度信息是记录在GL_DEPTH_BUFFER_BIT里的，而不是一张texture里

### 渲染skymap需要注意什么

vs中不需要乘Model矩阵，Position取xyww，因为想让skymap在最远处，同理，View矩阵需要去掉平移的那一列

glCullFace 因为是从里面看到外面，如果用的是场景中其他普通的cube需要改变cullface的面

glDepthFunc LEQUAL

### shader注意事项

max(dot, 0)

0.0 not 0

## 计算几何

### 如何判断点是否在三角形内

**重心坐标**

$$
\begin{cases}
P = λ1 * A + λ2 * B + λ3 * C \\ 
λ1 + λ2 + λ3 = 1 
\end{cases}
$$

带入P点与ABC三点坐标即可

$$
\begin{bmatrix} x \ y \ 1 \end{bmatrix}
\begin{bmatrix}
x1 & x2 & x3 \\
y1 & y2 & y3 \\
1 & 1 & 1
\end{bmatrix} =
\begin{bmatrix}
λ1 \
λ2 \
λ3
\end{bmatrix}
$$

如果矩阵可逆，则方程有唯一解(克拉默法则)

**叉积**

- 使用向量叉积检查点 `P` 是否在每条边的同一侧。
- 计算向量 `AP` 与 `AB`、向量 `BP` 与 `BC` 以及向量 `CP` 与 `CA` 的叉积。
- 如果这些叉积的符号都相同（或者至少有一个为零），那么点 `P` 在三角形内部或边界上。
- 如果叉积中有异号，则点 `P` 在三角形外部。


### 给定法线方向和入射光方向，怎么求反射方向

假设L和N都是单位向量

$$R = L - 2 * dot(L, N) * N$$

### 如何判断射线与AABB包围盒相交

设射线用一个点 $R_0$ (其起始位置) 和方向向量 $D$ 表示，其中 $D$ 通常为单位向量($L=R_0+tD$)。AABB由两个点定义，$(x_{min}, y_{min}, z_{min})$ 和 $(x_{max}, y_{max}, z_{max})$ 分别表示包围盒在各轴上的最小和最大坐标。

$$ 
t_{min} = \frac{(x_{min} - R0_x)}{D_x}, \quad t_{max} = \frac{(x_{max} - R0_x)}{D_x} \\
t\_{enter} = max(t\_{minX}, t\_{minY}, t\_{minZ}) \\
t\_{exit} = min(t\_{maxX}, t\_{maxY}, t\_{maxZ}) 
$$

!!! Warning 如果射线沿该轴的方向分量 $D$ 是 0，则需要特殊处理以避免除以零，这意味着射线在那个维度上是平行的，不会朝正或负方向移动。只有当射线的起点在该轴的最小值和最大值之间（例如，$x_{min} ≤ R_0.x ≤ x_{max}$时），射线在这个维度上与AABB相交

对于三个坐标轴重复上述计算过程，从中得到一组 **tmin**和 **tmax** 的最大值和最小值

如果 D 的分量是负数，我们需要交换 tmin 和 tmax 的计算结果，因为在这种情况下射线从最大面进入 AABB，并且从最小面离开。

如果满足以下条件之一，则射线不与 AABB 相交：
- 如果 **t\_enter** > **t\_exit**，说明射线在每个维度上都没有同时穿过 AABB。
- 如果 **t\_exit** < 0，说明交点发生在射线的反方向上，也就是说 AABB 在射线背后。
- 如果 **t\_enter** < 0 并且 **t\_exit** > 0，这意味着射线起点在 AABB 内部。

只有当 **t\_enter** <= **t\_exit** 并且 **t\_exit** >= 0 时，射线才与 AABB 相交。

### 球面积分

球面坐标系下的微小面积元素 $\textrm{d}A$ 可以由两个微分组成：一个与极角 $\theta$ 相关的圆弧长度$r\textrm{d}\theta$，另一个与方位角 $\phi$ 相关的圆周长$r\sin(\theta)\textrm{d}\phi$。这里的 $r$ 是球体的半径。

因此，在球的表面上的微小面积元素可以表示为：

$$\textrm{d}A = r^2 \sin(\theta) d\theta d\phi$$

然而，当我们谈论立体角 $d\omega$ 时，我们不是在考虑球面上的实际面积，而是考虑从球心朝向球面的一定方向上的视野范围。于是，立体角的微小元素等于球面上的微小面积元素除以球体半径的平方。

### 采样

采样的基础首先是生成均匀随机序列，使用伪随机数或是低差异序列。在此基础上基于分布的pdf或是cdf或其他算法去生成目标分布的采样值。

## 操作系统

## 网络

## 设计与项目

### ecs的优势与不足

组件交互：当组件之间需要频繁交互时，ECS的解耦本质可能导致设计复杂化  
多线程复杂性：虽然ECS天然支持并行处理，但正确地管理多线程以避免竞态条件、死锁及其他并发问题需要仔细考虑，并可能增加实现的复杂性。  
数据驱动的设计挑战：ECS鼓励数据驱动的设计，但这种设计对于定义清晰的业务逻辑有时会显得不够直接和容易理解。

组合优于继承：传统的面向对象编程（OOP）中可能出现深层次和复杂的继承结构，而在 ECS 中，实体的行为是通过添加或移除组件来动态定义的，无需继承。  
缓存命中：通过将数据组织为紧密排列的组件数组，ECS 能够提高 CPU 缓存效率，从而加速数据访问和处理速度。

### 序列化方案

Json

XML

**Protobuf**

假设我们有一个Protobuf消息，其中只有一个字段：

```proto
message SearchRequest {
  string query = 1;
}
```

如果我们想要序列化`SearchRequest`，并且`query`的值是"hello"，序列化的步骤将如下：

1. 首先计算键：
   - 字段号为1，类型为`string`，对应的wire type为2（length-delimited）。
   - 将字段号左移三位（1 << 3 = 8）并加上wire type（8 + 2 = 10）。
   - 数字10的Varint编码是1010（在二进制中就是它本身）。
2. 接着序列化值：
   - "hello"字符串长度为5，所以首先写入长度5的Varint表示。
   - 然后写入"hello"的ASCII编码。

!!! 字段号左移三位是为了给wire type留出空间

在反序列化时
1. **检查最高位**：查看该字节的最高位（第8位）。
   - 如果最高位为0，表示这是键的最后一个字节。
   - 如果最高位为1，表示后面还有其他字节也属于这个键的一部分。
2. **读取后续字节**（如果需要）：如果第一个字节的最高位是1，就继续读取下一个字节，并重复检查最高位的步骤。这个过程将持续进行，直到找到一个字节其最高位为0。
3. **组合字节**：将读取的字节按照顺序组合起来（忽略每个字节的最高位），形成完整的键值。

举个例子，如果你从数据流中得到了以下两个字节：`0xAC 0x02`。在二进制中这些字节表示为 `10101100 00000010`。由于第一个字节的最高位为1，这表明键不止一个字节长。然后你需要读取第二个字节，它的最高位为0，表示这是键的最后一个字节。你现在可以将这两个字节组合起来（去掉每个字节的最高位），得到实际的键值。
