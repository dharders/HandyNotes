#c-cpp #cg
## 2023.12.14

## c-cpp

### `char` `short` `int` `long` `long long`的长度

-   `char`：1 字节（按照标准，`char` 的大小是 1 字节）
-   `short`：至少 2 字节
-   `int`：至少与 `short` 一样长
-   `long`：至少 4 字节，并且至少与 `int` 一样长
-   `long long`：至少 8 字节，并且至少与 `long` 一样长

### 大端和小端的存储

**最高有效字节**（即“大端”）存储在内存的低地址端(网络字节序)   
**最低有效字节**（即“小端”）存储在内存的低地址端(x86)

### `malloc` 的底层实现

`malloc` 底层利用系统调用来从操作系统申请内存空间。在 Unix-like 系统中，这些系统调用可能是 `sbrk` 或 `mmap`（在现代系统中更常见）。

-   **`sbrk`**: 这个系统调用增加程序数据段的大小。`sbrk` 可以增加或减少数据段的尺寸，`malloc` 使用它来获取更多的内存。
-   **`mmap`**: 这个系统调用将文件或设备的一个区域映射到内存中，可以用于匿名映射（不与任何文件关联），从而为进程提供一块新的内存区域。

`malloc` 需要跟踪所有已分配和未分配的内存，它使用各种内存管理算法来有效地跟踪、分配和释放内存，例如：

-   **Free Lists**: 管理一系列未分配内存块的链表。(glibc (ptmalloc))
-   **Buddy System**: 将内存分割成大小为 2 的幂的块，并通过合并和分割相邻的内存块来管理内存。
-   **Slab Allocation**: 特别适用于频繁分配和释放的相同大小的对象。
-   **Segmented Lists**: 根据大小范围将内存分段，每个段有自己的空闲列表。

`malloc` 函数不保证可重入，因为它可能会修改全局或静态的内部数据结构，例如用于跟踪空闲内存和已分配内存的数据结构。

### cpp内存布局

C++对象在内存中的布局可以细分为以下几个区域：

- **代码段（Code Segment/Text Segment）**：存放程序的机器代码。
- **数据段（Data Segment）**：存放初始化的全局变量和静态变量。
- **BSS段（Block Started by Symbol）**：存放未初始化的全局变量和静态变量。
- **堆（Heap）**：用于动态内存分配，通过`new`、`malloc`等操作进行分配和收回。
- **栈（Stack）**：存放函数的参数值、局部变量等。

## 计算几何

### 如何判断点是否在三角形内

**重心坐标**

$$
\begin{cases}
P = λ1 * A + λ2 * B + λ3 * C \\ 
λ1 + λ2 + λ3 = 1 
\end{cases}
$$

带入P点与ABC三点坐标即可

$$
\begin{bmatrix} x \ y \ 1 \end{bmatrix}
\begin{bmatrix}
x1 & x2 & x3 \\
y1 & y2 & y3 \\
1 & 1 & 1
\end{bmatrix} =
\begin{bmatrix}
λ1 \
λ2 \
λ3
\end{bmatrix}
$$

如果矩阵可逆，则方程有唯一解(克拉默法则)

**叉积**

- 使用向量叉积检查点 `P` 是否在每条边的同一侧。
- 计算向量 `AP` 与 `AB`、向量 `BP` 与 `BC` 以及向量 `CP` 与 `CA` 的叉积。
- 如果这些叉积的符号都相同（或者至少有一个为零），那么点 `P` 在三角形内部或边界上。
- 如果叉积中有异号，则点 `P` 在三角形外部。


### 给定法线方向和入射光方向，怎么求反射方向

假设L和N都是单位向量

$$R = L - 2 * dot(L, N) * N$$

### 如何判断射线与AABB包围盒相交

设射线用一个点 $R_0$ (其起始位置) 和方向向量 $D$ 表示，其中 $D$ 通常为单位向量($L=R_0+tD$)。AABB由两个点定义，$(x_{min}, y_{min}, z_{min})$ 和 $(x_{max}, y_{max}, z_{max})$ 分别表示包围盒在各轴上的最小和最大坐标。

$$ 
t_{min} = \frac{(x_{min} - R0_x)}{D_x}, \quad t_{max} = \frac{(x_{max} - R0_x)}{D_x} \\
t\_{enter} = max(t\_{minX}, t\_{minY}, t\_{minZ}) \\
t\_{exit} = min(t\_{maxX}, t\_{maxY}, t\_{maxZ}) 
$$

!!! Warning 如果射线沿该轴的方向分量 $D$ 是 0，则需要特殊处理以避免除以零，这意味着射线在那个维度上是平行的，不会朝正或负方向移动。只有当射线的起点在该轴的最小值和最大值之间（例如，$x_{min} ≤ R_0.x ≤ x_{max}$时），射线在这个维度上与AABB相交

对于三个坐标轴重复上述计算过程，从中得到一组 **tmin**和 **tmax** 的最大值和最小值

如果 D 的分量是负数，我们需要交换 tmin 和 tmax 的计算结果，因为在这种情况下射线从最大面进入 AABB，并且从最小面离开。

如果满足以下条件之一，则射线不与 AABB 相交：
- 如果 **t\_enter** > **t\_exit**，说明射线在每个维度上都没有同时穿过 AABB。
- 如果 **t\_exit** < 0，说明交点发生在射线的反方向上，也就是说 AABB 在射线背后。
- 如果 **t\_enter** < 0 并且 **t\_exit** > 0，这意味着射线起点在 AABB 内部。

只有当 **t\_enter** <= **t\_exit** 并且 **t\_exit** >= 0 时，射线才与 AABB 相交。

## 操作系统

## 网络

## 设计与项目

### ecs的优势与不足

组件交互：当组件之间需要频繁交互时，ECS的解耦本质可能导致设计复杂化  
多线程复杂性：虽然ECS天然支持并行处理，但正确地管理多线程以避免竞态条件、死锁及其他并发问题需要仔细考虑，并可能增加实现的复杂性。  
数据驱动的设计挑战：ECS鼓励数据驱动的设计，但这种设计对于定义清晰的业务逻辑有时会显得不够直接和容易理解。

组合优于继承：传统的面向对象编程（OOP）中可能出现深层次和复杂的继承结构，而在 ECS 中，实体的行为是通过添加或移除组件来动态定义的，无需继承。  
缓存命中：通过将数据组织为紧密排列的组件数组，ECS 能够提高 CPU 缓存效率，从而加速数据访问和处理速度。

### 序列化方案

Json

XML

**Protobuf**

假设我们有一个Protobuf消息，其中只有一个字段：

```proto
message SearchRequest {
  string query = 1;
}
```

如果我们想要序列化`SearchRequest`，并且`query`的值是"hello"，序列化的步骤将如下：

1. 首先计算键：
   - 字段号为1，类型为`string`，对应的wire type为2（length-delimited）。
   - 将字段号左移三位（1 << 3 = 8）并加上wire type（8 + 2 = 10）。
   - 数字10的Varint编码是1010（在二进制中就是它本身）。
2. 接着序列化值：
   - "hello"字符串长度为5，所以首先写入长度5的Varint表示。
   - 然后写入"hello"的ASCII编码。

!!! 字段号左移三位是为了给wire type留出空间

在反序列化时
1. **检查最高位**：查看该字节的最高位（第8位）。
   - 如果最高位为0，表示这是键的最后一个字节。
   - 如果最高位为1，表示后面还有其他字节也属于这个键的一部分。
2. **读取后续字节**（如果需要）：如果第一个字节的最高位是1，就继续读取下一个字节，并重复检查最高位的步骤。这个过程将持续进行，直到找到一个字节其最高位为0。
3. **组合字节**：将读取的字节按照顺序组合起来（忽略每个字节的最高位），形成完整的键值。

举个例子，如果你从数据流中得到了以下两个字节：`0xAC 0x02`。在二进制中这些字节表示为 `10101100 00000010`。由于第一个字节的最高位为1，这表明键不止一个字节长。然后你需要读取第二个字节，它的最高位为0，表示这是键的最后一个字节。你现在可以将这两个字节组合起来（去掉每个字节的最高位），得到实际的键值。
